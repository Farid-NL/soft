#!/usr/bin/env bash
# This script was generated by bashly 1.2.2 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
soft_usage() {
  printf "soft - Personal Fedora installer\n\n"

  printf "%s\n" "Usage:"
  printf "  soft COMMAND\n"
  printf "  soft [COMMAND] --help | -h\n"
  printf "  soft --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all programs\n" "list       "
  printf "  %s   Install given program\n" "install    "
  printf "  %s   Install all programs\n" "install-all"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  soft ls\n"
    printf "  soft install yakuake\n"
    printf "  soft install-all\n"
    echo

  fi
}

# :command.usage
soft_list_usage() {
  printf "soft list - List all programs\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  soft list [OPTIONS]\n"
  printf "  soft list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--status, -s"
    printf "    Show status of every program\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
soft_install_usage() {
  printf "soft install - Install given program\n\n"
  printf "Alias: i\n"
  echo

  printf "%s\n" "Usage:"
  printf "  soft install PROGRAM\n"
  printf "  soft install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PROGRAM"
    printf "\n"
    echo

  fi
}

# :command.usage
soft_install_all_usage() {
  printf "soft install-all - Install all programs\n\n"
  printf "Alias: all\n"
  echo

  printf "%s\n" "Usage:"
  printf "  soft install-all\n"
  printf "  soft install-all --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/checkers.sh
declare -a simple_software

# Programs that only need `sudo dnf -y install <program>`
# in order to be installed
simple_software=(
  git
  fzf
  eza
  git-delta
  bat
  bfs
  neovim
  yakuake
)

check_dnf_package() {
  if dnf -C list --installed "$1" 2> /dev/null > /dev/null; then
    echo true
  else
    echo false
  fi
}

check_file() {
  if [ -f "$1" ]; then
    echo true
  else
    echo false
  fi
}

# src/lib/installers.sh
install_dnf_package() {
  if $(check_dnf_package "$1"); then
    echo "$1 already installed"
  else
    sudo dnf -y install "$1"
  fi
}

install_zoxide() {
  if $(check_file "${HOME}/.local/bin/zoxide"); then
    echo "zoxide already installed"
  else
    curl -sSfL https://raw.githubusercontent.com/ajeetdsouza/zoxide/main/install.sh | sh
  fi
}

install_lazygit() {
  if $(check_dnf_package lazygit); then
    echo "lazygit already installed"
  else
    sudo dnf copr enable atim/lazygit -y
    sudo dnf -y install lazygit
  fi
}

install_code() {
  if $(check_dnf_package code); then
    echo "code already installed"
  else
    sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
    echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" | sudo tee /etc/yum.repos.d/vscode.repo > /dev/null
    dnf check-update
    sudo dnf -y install code
  fi
}

install_docker() {
  if $(check_dnf_package docker-ce); then
    echo "docker already installed"
  else
    sudo dnf -y install dnf-plugins-core
    sudo dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.rep
    sudo dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    sudo usermod -aG docker $USER
    newgrp docker
  fi
}

install_gh() {
  if $(check_dnf_package gh); then
    echo "gh already installed"
  else
    sudo dnf config-manager --add-repo https://cli.github.com/packages/rpm/gh-cli.repo
    sudo dnf install gh --repo gh-cli
  fi
}

install_jetbrains-toolbox() {
  if $(check_file "${HOME}/.local/share/JetBrains/Toolbox/bin/jetbrains-toolbox"); then
    echo "jetbrains-toolbox already installed"
  else
    wget -q --progress=bar:force:noscroll "https://data.services.jetbrains.com/products/download?platform=linux&code=TBA" -O /tmp/jetbrains-toolbox.tar.gz
    tar -xf /tmp/jetbrains-toolbox.tar.gz -C ~/Downloads --strip-components=1
    echo -e "\nAppimage extracted in ${HOME}/Downloads"
  fi
}

# :command.command_functions
# :command.function
soft_list_command() {
  # src/list_command.sh
  status=${args[--status]}

  # Store the way a program status is checked
  declare -A software_checkers

  # Store the installation status of every program
  declare -A software_status

  populate_checkers() {
    software_checkers=(
      [lazygit]="check_dnf_package"
      [code]="check_dnf_package"
      [docker-ce]="check_dnf_package"
      [zoxide]="check_file ${HOME}/.local/bin/zoxide"
      [jetbrains-toolbox]="check_file ${HOME}/.local/share/JetBrains/Toolbox/bin/jetbrains-toolbox"
    )

    # Add the 'simple software' to $software_checkers
    for software in "${simple_software[@]}"; do
      software_checkers[$software]="check_dnf_package"
    done
  }

  populate_status() {
    populate_checkers

    for software in "${!software_checkers[@]}"; do
      local checker="${software_checkers[$software]}"

      if [[ "${checker}" != "check_dnf_package" ]]; then
        software_status["${software}"]=$(eval "${checker}")
      else
        software_status["${software}"]=$(eval "${checker}" "${software}")
      fi
    done
  }

  is_installed() {
    if "$1"; then
      echo "✅"
    else
      echo "❌"
    fi
  }

  if [[ "${status}" ]]; then
    populate_status

    printf "┌───────────────────┬────┐\n"
    for software in "${!software_status[@]}"; do
      local status="${software_status[$software]}"
      printf "│ %17s │ %s │\n" "${software}" "$(is_installed ${status})"
    done
    printf "└───────────────────┴────┘\n"

  else
    populate_checkers

    for software in "${!software_checkers[@]}"; do
      echo "${software}"
    done
  fi

}

# :command.function
soft_install_command() {
  # src/install_command.sh
  program=${args[program]}

  # Simple programs
  if [[ ${simple_software[@]} =~ "${program}" ]]; then
    install_dnf_package "${program}"
    return
  fi

  # Custom programs
  case "${program}" in
    zoxide|\
    lazygit|\
    code|\
    docker|\
    gh|\
    jetbrains-toolbox)
      eval "install_${program}"
      ;;

    *)
      echo "Program not in the list" >&2
      exit 1
      ;;
  esac

}

# :command.function
soft_install_all_command() {
  # src/install_all_command.sh
  # Simple software
  for software in "${simple_software[@]}"; do
    install_dnf_package "${software}"
  done

  # Custom software
  install_zoxide
  install_lazygit
  install_code
  install_docker
  install_gh
  install_jetbrains-toolbox

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        soft_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list | ls)
      action="list"
      shift
      soft_list_parse_requirements "$@"
      shift $#
      ;;

    install | i)
      action="install"
      shift
      soft_install_parse_requirements "$@"
      shift $#
      ;;

    install-all | all)
      action="install-all"
      shift
      soft_install_all_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      soft_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
soft_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        soft_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --status | -s)

        # :flag.case_no_arg
        args['--status']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
soft_install_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        soft_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['program']+x} ]]; then
          args['program']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['program']+x} ]]; then
    printf "missing required argument: PROGRAM\nusage: soft install PROGRAM\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
soft_install_all_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        soft_install_all_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="install-all"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "list") soft_list_command ;;
    "install") soft_install_command ;;
    "install-all") soft_install_all_command ;;
  esac
}

initialize
run "$@"
